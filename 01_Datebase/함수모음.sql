    <SELECT>
    SELECT 가지고오고싶은 정보 FROM 테이블;
    SELECT 컬럼1, 컬럼2, 컬럼3... FROM 테이블;
    -- SELECT절 컬렴명 작성부분에 산술연산을 할 수 있다.
    --데이터베이스에서 NULL은 빈값을 의미한다.
--모든 연산에 NULL이 포함된 경우. 결과는 NULL이된다.

--사원명, 입사일, 근무일수를 EMPLOYEE테이블에서 조회
--데이터베이스에서는 날짜를 계산할 때 덧셈 뺄셈이 가능하다.
--현제시간 - 입사일 = 근무한시간
--DATE - DATE => 결과는 무조건 일로 표시가 된다.
-- 코드실행시 현제날짜를 표시하는 상수 : SYSDATE[년/월/일/시/분/초]
//DUAL테이블은 오라클에서 제공하는 가상테이블이다.    
    <컬럼에 별칭 지정하기>
    산술연산을 하게되면 컬럼명이 지저분해진다. 이때 컬럼명에 별칭을 부여해서 깔끔하게 가져올 수 있다.
    [표현법]
    컬럼명 별칭 / 컬럼명 AS 별칭 / 컬럼명 "별칭" / 컬럼명 AS "별칭"    
    <리터럴>
    임의로 지정한 문자열('')
    <연결연산자: ||>
    여러 컬럼값들을 마치 하나의 컬럼처럼 연결할 수 있다.    
    <DISTINCT>
    중복제거 - 컬럼에 표시된 값들을 한번씩만 조회하고자 할 때 사용    
 --위DISTINCT 한 명령어에서 한번만 사용가능   
    <WHERE 절>
    조회하고자하는 테이블로부터 특정 조건에 만족하는 데이터만 조회할 때 사용
    조건식에서도 다양한 연산자를 사용할 수 있다.
    
    [표현법]
    SELECT 컬럼, 컬럼, 컬럼
    FROM 테이블명
    WHERE 조건;
    
    >>비교연산자<<
    >, <,  >=, <= :대소비교
    = : 양쪽이 동일하다.
    !=, ^=, <> : 양쪽이 다르다.    
    <AND, OR연산자>
    조건을 여러개 연결할 때 사용한다.
    [표현법]
    조건A AND 조건B -> 조건A와 조건B가 모두 만족하는 값만 참으로 한다.
    조건A OR 조건B -> 조건A와 조건B중 하나만 만족해도 값을 참으로 한다.
    
    <BETWEEN AND>
    조건식에 사용되는 구문
    몇이상 몇이하인 범위에 대한 조건을 제시할 때 주로 사용하는 연산자(이상, 이하만 가능)
    [표현법]
    비교대상 컬럼 BETWEEN 하안값 AND 상한값;    
-- NOT : 논리부정 연산자
-- 컬럼명앞에 또는 BETWEEN앞에 선언 가능

-- NULL을 비교연산할때는 =를 사용할 수 없다
-- NULL값을 비교할 때는 IS NULL, IS NOT NULL을 사용한다.
    <LIKE>
    비교하고자하는 컬럼값이 내가 제시한 특정 패턴에 만족할 경우 조회
    
    [표현법]
    비교할 대상컬럼 LIKE '특정패턴'; -> 일치하는 것만 가져온다
    
    특정패턴을 제시할 때 와일드카드라는 특정패턴이 정의되어있다.
    1. '%' : 포함문자 검색(0글자 이상 전부 조회)
    EX) 비교할 대상 컬럼 LIKE '문자%' : 비교할대상컬럼값 중에서 해당문자로 시작하는 값들을 전부 가져온다.
        비교할 대상 컬럼 LIKE '%문자' : 비교할대상컬럼값 중에서 해당문자로 끝나는 값들을 전부 가져온다.
        비교할 대상 컬럼 LIKE '%문자%' : 비교할대상컬럼값 중에서 해당문자가 포함된 값은 전부 가져온다.
    
    2, '_': 1글자를 대체검색할 때 사용
    EX) 비교할 대상 컬럼 LIKE '_문자' : 비교할대상컬럼값 문자앞에 아무글자나 딱 한글자가 있는 값을 조회
        비교할 대상 컬럼 LIKE '문자_' : 비교할대상컬럼값 문자뒤에 아무글자나 딱 한글자가 있는 값을 조회
        비교할 대상 컬럼 LIKE '_문자_' : 비교할대상컬럼값 문자앞뒤에 아무글자나 딱 한글자씩 있는 값을 조회
        
        비교할 대상 컬럼 LIKE '__문자___' : 내가 원하는 형태로 _를 통해서 문자수를 조절할 수 있다.    
    
--WHERE EMAIL LIKE '____%'; -> 와일드카드로 인식되기 때문에 정상적으로 출력할 수 없다.
--와일드카드와 일반문자를 구분해줘야한다.
--데이터값으로 취급하고싶은 와일드카드 문자 앞에 나만의 탈출문자를 제시해서 탈출시켜주면된다.
--ESCAPE OPTION을 등록해서 사용
WHERE EMAIL LIKE '___/_%' ESCAPE '/';    
    <IN>
    WHERE절에 비교대상 컬럼값이 내가 제시한 목록중에 일치하는 값이 있는지를 검사하는 문법

    [표현법]
    비교대상 컬럼 IN ('값', '값', '값'..)    
    
    <연산자 우선순위>
    1. 산술연산자
    2. 연결연산자
    3. 비교연산자
    4. IS NULL/ LIKE/ IN
    5. BETWEEN A AND B
    6. NOT
    7. AND
    8. OR    
    
    <ORDER BY절>
    SELECT문 가장 마지막 줄에 작성, 싱행순서또한 가장 마지막에 실행한다.
    
    [표현법]
    SELECT 조회할 컬럼...
    FROM 조회할 테이블
    WHERE 조건식
    ORDER BY 정렬기준이 될 컬럼명 | 별칭 | 컬럼순번 [ASC | DESC] [NULLS FIRST | NULLS LAST]

    - ASC : 오름차순(작은 값으로 시작해서 점점 커지는 것) -> 기본값
    - DESC : 내림차순(큰값으로 시작해서 값이 점점 줄어드는 것)
    
    --NULL은 기본적으로 가장 큰 값으로 분류해서 정렬한다.
    - NULLS FIRST : 정렬하고자하는 컬럼값에 NULL이 있을 경우 해당데이터 맨 앞에 배치(DESC일 때 기본값)
    - NULLS LAST : 정렬하고자하는 컬럼값에 NULL이 있을 경우 해당데이터 맨 뒤에 배치(ASC일 때 기본값)    
 --ORDER BY BONUS DESC; -- NULLS FIRST가 기본값으로 적용
--정렬기준에 컬럼값이 동일할 경우 그 다음차순을 위해서 여러개를 제시할 수 있다.   
    
    <함수 FUNCTION>
    전달된 컬럼값을 읽어들여서 함수를 실행한 결과를 반환
    
    -단일행 함수 : N개의 값을 읽어들여서 N개의 결과값을 리턴(매행마다 함수실행결과를 반환)
    -그룹함수 : N개의 값을 읽어들여서 1개의 결과값을 리턴(그룹을 지어 그룹별로 함수 실행결과를 반환)
    
    >>SELECT 절에 단일행 함수와 그룹함수를 함께 사용하지 못한다.
    왜? 결과 행의 갯수가 서로 다르기 때문에
    
    >>함수식을 사용할 수 있는 위치 :SELECT절 WHERE절 ORDER BY절 GROUP BY절 HAVING절    
    
    <문자 처리 함수>
    *LENGTH(컬럼 | '문자열') : 해당 문자열의 글자수를 반환
    *LENGTHB(컬럼 | '문자열') : 해당 문자열의 바이트수를 반환
    
    '최' '나' 'ㄱ' 한굴은 글자당 3BYTE
    영문자, 숫자, 특수문자 글자당 1BYTE    
    
    *INSTR
    문자열로부터 특정 문자의 시작위치를 찾아서 반환
    
    INSTR(컬럼 | '문자열', '찾고자하는 문자', ['찾을 위치의 시작값', 순번]) -> 결과는 NUMBER로 나옴    
 
    *SUBSTR / 자주사용
    문자열에서 특정 문자열을 추출해서 반환
    
    [표현법]
    SUBSTR(컬럼 | '문자열', 추출할 시작위치, [추출문자 갯수])
    
    *LPAD / RPAD
    문자열을 조회할 때 통일감있게 조회하고자 할 때 사용
    
    [표현법]
    LPAD/RPAD(STRING, 최종적으로 반환할 문자열의 길이, [덧붙이고자하는 문자])    
    
/*
    *LTRIM/RTRIM
    문자열에서 특정 문자를 제거한 나머지를 반환
    LTRIM/RTRIM(컬럼 | '문자열', [제거하고자하는 문자들])
    
    문자열의 왼쪽 혹은 오른쪽에서 제거하고자하는 문자들을 찾아서 제거한 나머지 문자열 반환    
    
    *TRIM
    문자열의 앞/뒤/양쪽에 있는 저장한 문자들을 제거한 나머지 문자열 반환
    TRIM([LEADING | TRAILING | BOTH] 제거하고자하는 문자열 FROM 문자열)    
    
    
 /*
    *LOWER / UPPER / INITCAP
    LOWER : 다 소문자로 변경한 문자열 반환
    UPPER : 다 대문자로 변경한 문자열 반환
    INITCAP : 띄어쓰기 기준 첫글자마다 대문자로 변경한 문자열 반환
*/   
    
    *CONCAT
    문자열 두개 전달받아서 하나로 합친 후 반환
    CONCAT(STRING1, STRING2)

    *REPLACE
    특정문자열에서 특정부분을 다른 부분으로 교체
    REPLACE(문자열, 찾을 문자열, 변경할 문자열)    
    
  ;SELECT EMAIL, REPLACE(EMAIL, 'C##SERVER', 'kh')
FROM EMPLOYEE;  
    
       <숫자처리함수>
    *ABS
    숫자의 절대값을 구햊는 함수 
    
    
        *MOD
    두 수를 나눈 나머지값을 반환
    MOD(NUMBER, NUMBER)
    
    *ROUND
    반올림한 결과를 반환
    ROUND(NUMBER, [위치])    
    
    *CEIL
    올림처리를 위한 함수
    CEIL(NUMBER)    
    
    TRUNNC, FLOOR
    버림처리 함수
    
    TRUNC(NUMBER, [위치])
    FLOOR(NUMBER)    
    
-- *SYSDATE : 시스템의 현재 날짜및 시간을 반환    
    
--*MONTHS_BETWEEN : 두 날짜 사이의 개월 수    
SELECT EMP_NAME, HIRE_DATE, FLOOR(SYSDATE - HIRE_DATE);    

--*ADD_MONTHS : 특정 날짜에 NUMBER개월수를 더해서 반환
SELECT ADD_MONTHS(SYSDATE, 7) FROM DUAL;    
    
--*NEXT_DAY(DATE, 요일(문자 | 숫자)) : 특정날짜 이후 가장 가까운 요일의 날짜를 반환
SELECT NEXT_DAY(SYSDATE, '토요일') FROM DUAL;    
    
    *EXTRACT : 특정 날짜로부터 년|월|일 값을 추출해서 반환하는 함수
    [표현법]
    EXTRACT(YEAR FROM DATE) : 연도만 추출
    EXTRACT(MONTH FROM DATE) : 월만 추출
    EXTRACT(DAY FROM DATE) : 일만 추출
    
    [형변환 함수]
    *TO_CHAR : 숫자타입 또는 날짜타입의 값을 문자타입으로 변환시켜주는 함수
    
    [표현법]
    TO_CHAR(숫자 | 문자,  [포멧])    
    
    TO_DATE : 숫자타입 또는 문자타입을 날짜타입으로 변경하는 함수
    
    TO_DATE(숫자 | 문자, [포맷]) -> DATE    
    
     TO_NUMBER : 문자타입의 데이터를 숫자타입으로 변환시켜주는 함수
    
    [표현법]
    TO_NUMBER(문자, [포멧])   
    
    [NULL처리 함수]
*/

--*NVL(컬럼, 해당컬럼이 NULL일 경우 보여줄 값)
SELECT EMP_NAME, BONUS, NVL(BONUS, 0)
    
    
 --*NVL2(컬럼, 반환값1, 반환값2)
--반환값1 : 해당컬럼이 존재하면 보여줄 값
--반환값2 : 해당컬럼이 존재하지 않으면 보여줄 값
SELECT EMP_NAME, BONUS, NVL2(BONUS, 'O', 'X')   
    
--* NULLIF(비교대상1, 비교대상2)
-- 두 값이 일치하면 NULL, 일치하지 않으면 비교대상1 반환
SELECT NULLIF('123', '123') FROM DUAL;
SELECT NULLIF('123', '456') FROM DUAL;    
    
    
    [선택함수]
    *DECODE(비교하고자하는 대상, 비교값1, 결과값1, 비교값2, 결과값2 ...)    
    
    *CASE WHEN THEN
    CASE
        WHEN 조건식1 THEN 결과값1
        WHEN 조건식2 THEN 결과값2
        ...
        ELSE 결과값
    END
    
    
-- 1.SUM(숫자타입컬럼) : 해당컬럼값들의 총 합계를 구해서 반환해주는 함수    
    
--2. AVG(NUMBER) : 해당 컬럼값들의 평균을 구해서 반환    
    
--3. MIN(모든 타입 가능) : 해당 컬럼값 중 가장 작은 값을 구해서 반환    
    

--4. MAX(모든 타입 가능) : 해당 컬럼값 중 가장 큰 값을 구해서 반환    
    
    

--5. COUNT(* | 컬럼 | DISTINCT 컬럼) : 해당 조건에 맞는 행의 갯수를 세서 반환
--COUNT(*) : 조회된 결과에 모든 행의 갯수를 세서 반환
--COUNT(컬럼) : 제시한 해당 컬럼값이 NULL이 아닌것만 행의 수를 세서 반환
--COUNT(DISTINCT 컬럼) : 해당 컬럼값 중복을 제거한 후 행의 갯수를 세서 반환    
    
    <GROUP BY>
    그룹기준을 제시할 수 있는 구문(해당 그룹기준별로 여러 그룹으로 묶을 수 있음)
    여러개의 값들을 하나의 그룹으로 묶어서 처리하는 목적으로 사용    
    
--GROUP BY절에 함수식 사용가능(그룹을 나눌 수 있는 기준만 넣어주면 된다.)    
    
SELECT DECODE(SUBSTR(EMP_NO, 8, 1), '1', '남', '2', '여'), COUNT(*)
FROM EMPLOYEE
GROUP BY SUBSTR(EMP_NO, 8, 1);    
--GROUP BY절에 여러컬럼을 기술할 수 있음
    
    [HAVING]
    그룹에 대한 조건을 제시할 때 사용되는 구문(주로 그룹함수식을 가지고 조건을 만든다.)
    
    
    SELECT *                                      -- 5
    FROM 테이블                                    -- 1
    WHERE 조건식                                   -- 2
    GROUP BY 그룹의 기준이되는 컬럼 | 함수식          -- 3
    HAVING 조건식                                  -- 4    
    ORDER BY 정렬기준 컬럼                          -- 6    
    (오라클에는 존재X)LIMIT    
    
    
/*
    <JOIN>
    두개 이상의 테이블에서 데이터를 조회하고자 할 때 사용되는 구문
    조회 결과는 하나의 결과(RESULT SET)를 반환한다.
    
    관계형 데이터베이스에서는 최소한의 데이터를 각각의 테이블에 담고 있음
    (무작정 다 조회해 오는 것이 아니라 각 테이블간 연결고리(외래키)를 통해 데이터를 매칭시켜 조회해야한다.)

    JOIN은 크게 "오라클 전용구문" "ANSI 구문"
    
    [용어정리]
        오라클 전용구문        |       ANSI구문
    -------------------------------------------------------
          등가조인            |        내부조인
         (EQUAL JOIN)        |      (INNER JOIN)
    ----------------------------------------------------------
          포괄조인            |        외부조인
    ---------------------------------------------------------
        자체조인/비등가조인    |         
*/    
    
/*
    1. 등가조인(EQUAL JOIN) / 내부조인(INNER JOIN)
    연결시키는 컬럼의 값이 일치하는 행들만 조회(일치하는 값이 없는 행은 조회 제외)
*/
-->오라클 전용구문
-- FROM절에 조회하고자하는 테이블을 나열(,구분)
-- WHERE절에 매칭시킬 컬럼에대한 조건을 제시

--1. 연결할 두 컬럼명이 다른 경우(EMPLOYEE : DEPT_CODE / DEPARTMENT : DEPT_ID)    
--전체 사원들의 사번, 사원명, 부서코드, 부서명
SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

--2. 연결할 두 컬럼명이 동일한 경우
--전체 사언들의 사번, 사원명, 직급코드, 직급명
SELECT EMP_ID, EMP_NAME, J.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;

--추가적인 조건제시
--직급이 대리인 사원의 사번, 사원명, 직급명, 급여조회
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE
  AND JOB_NAME = '대리';
  
  
-->ANSI구문
--FROM절에 기준이되는 테이블 하나만 기술한다.
--JOIN절에 같이 조인하고자하는 테이블 기술 + 매칭시킬 컬럼에대한 조건
--[INNER] JOIN USING / JOIN ON

--1. 연결할 두 컬럼명이 다른 경우(EMPLOYEE : DEPT_CODE / DEPARTMENT : DEPT_ID)
--전체 사원들의 사번, 사원명, 부서코드, 부서명
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

--2. 연결할 두 컬럼명이 동일한 경우
--전체 사언들의 사번, 사원명, 직급코드, 직급명
SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

--추가적인 조건제시
--직급이 대리인 사원의 사번, 사원명, 직급명, 급여조회
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE
INNER JOIN JOB USING(JOB_CODE)
WHERE JOB_NAME = '대리';    
    
/*
    2. 포괄조인 / 외부조인(OUTER JOIN)
    두 테이블간의 JOIN시 일치하지 않는 행도 포함시켜 조회가능
    단, 반드시 LEFT/RIGHT를 지정해야됩니다.(어떤테이블이 기준이냐)
*/    
    
 
-- FULL [OUTER] JOIN : 두 테이블이 가진 모든 행을 조회할 수 있다.   
    
 /*
    3. 비등가 조인
    매칭시킬 컬럼에 대한 조건 작성시 '='를 사용하지 않는 조인문
    ANSI구문 사용시 JOIN ON만 사용가능
    
    범위(수치적 범위, 기간적 범위)기반조인을 구현할 때 주로 사용한다.
*/   
    
    
 /*
    4.자체조인(SELF JOIN)
    같은 테이블을 다시한번 조인하는 경우
    - 하나의 테이블에서 서로 다른 두개의 행을 비교해야하는 경우 사용
    - 동일한 테이블을 조인하는 것이기 때문에 별칭을 사용해서 구분해야한다.
*/

--전체 사원의 사원사번, 사원명, 사원부서코드  --> EMPLOYEE E
--          , 사수사번, 사수의사원명, 사수의부서코드 --> EMPLOYEE M   
    
/*
    <다중조인>
    2개이상의 테이블을 가지고 JOIN할 수 있다.
*/    
    
/*
    내추럴조인(NATURAL JOIN)
    두 테이블 간에 공통된 컬럼이름을 자동으로 기준을 정해서 조인하는 방식
    ON이나 USING 조건을 지정하지 않아도 두 테이블간 공통된 컬럼을 기반으로 조인\
    
    동일한 컬럼이 있을 경우에만 정상적인 조인이 가능하며 명시적이지 않고 조인조건을 정확하게
    기술하기 어렵다.
*/    
    
  /*
    *서브쿼리
    -하나의 SQL문 안에 포함된 또다른 SELECT문
    -메인 SQL문을 위해 보조 역할을 하는 쿼리
*/  
    
--서브쿼리 예시1) 노옹철 사원과 같은 부서에 속한 사원들 전체 조회

SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE = 'D9';

--노옹철 사원의 부서는?
SELECT DEPT_CODE
FROM EMPLOYEE
WHERE EMP_NAME = '노옹철';

--위에 두 쿼리를 하나의 쿼리로 변경하자
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE = (SELECT DEPT_CODE
                    FROM EMPLOYEE
                    WHERE EMP_NAME = '노옹철');
                        
    
/*
    *서브쿼리의 구분
    서브쿼리를 수행한 결과값이 몇행 몇열로 나오느냐에 따라서 분류
    --단일행 서브쿼리 : 서브쿼리의 조회 결과값이 오로지 한개일 때
    --다중행 서브쿼리 : 서브쿼리의 조회 결과값이 여러행일 때(여러행 한열)
    --다중열 서브쿼리 : 서브쿼리의 조회 결과값이 한행이지만 컬럼이 여러개일 때
    --다중행 다중열 서브쿼리 : 서브쿼리의 조회 결과값이 여러행 여러컬럼일 때
    
    >> 서브쿼리의 결과값에 따라서 서브쿼리 앞쪽에 연산자가 달라진다.
*/

/*
    1. 단일행 서브쿼리
    서브쿼리 결과로 값이 1개일 때 사용한다(한행 한열)
    일반적으로 비교연산자 사용 가능
    
    = != > <= ...
*/    
    
/*
    2. 다중행 서브쿼리
    서브쿼리를 수행한 결과값이 여러행일 때(컬럼은 한개)
    IN, ANY, ALL같은 다중행 연산자와 함께 사용
    
    비교대상 IN (서브쿼리) : 여러개의 결과값 중에서 한개라도 일치하는 값이 있다면 조회
    비교대상 > ANY (서브쿼리): 여러개의 결과값 중에서 한개라도 클 경우 조회
    비교대상 < ANY (서브쿼리): 여러개의 결과값 중에서 한개라도 작을 경우 조회
    비교대상 > ALL (서브쿼리): 여러개의 모든 결과값들 보다 클 경우 조회
    비교대상 < ALL (서브쿼리): 여러개의 모든 결과값들 보다 작을 경우 조회
*/

/*
    3. 다중열 서브쿼리
    결과값은 한 행이지만 나열된 컬럼수가 여러개일 경우(두개 이상의 컬럼)
*/    
    
--다중열 서브쿼리
--튜플비교 : 두개 이상의 열(컬럼)을 조합해서 비교하는 방식    
    
/*
    4. 다중행 다중열 서브쿼리
    서브쿼리의 조회 결과값이 여러행 여러열일 경우 (주로 튜플비교와 함께 사용)
*/

/*
    5. 인라인 뷰
       FROM절에서 서브쿼리를 작성한 것
       서브쿼리에 수행 결과를 마치 테이블처럼 사용한다.
*/
    
 --> 인라인뷰를 주로 사용하는 경우 -> TOP-N분석 : 상위몇개만 조회
 -- 전 직원중 급여가 가장 높은 5명만 조회
 --ROWNUM : 오라클에서 제공해주는 컬럼, 조회된 순서대로 1부터 순번을 부여해주는 컬럼
 --         ROWNUM은 FROM절에서 이미 결정된다.
 SELECT ROWNUM, EMP_NAME, SALARY
 FROM EMPLOYEE
 ORDER BY SALARY DESC;    
    
  --> ORDER BY절이 수행된 결과를 가지고 ROWNUM부여 -> 상위5명   
    
--각 부서별 평균급여가 높은 3개의 부서 조회
--인라인뷰에 있는 산술식으로된 컬럼을 가져오기 위해서는
--별칭을 부여해야한다.
    
    
    
    
    